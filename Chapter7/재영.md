# Chapter 07: 객체지향 프로그래밍 II

## 1. 상속 (Inheritance)

### 정의

* 기존 **클래스(조상)** 를 재사용해 **새 클래스(자손)** 를 만드는 것 (`extends`).
* 자손은 조상의 **모든 멤버(필드/메서드)** 를 상속받아 **코드 재사용/중복 제거**에 유리.

### 핵심 규칙

* **생성자 / 초기화 블록은 상속 X** (멤버만 상속).
* 자손의 멤버 수 ≥ 조상 멤버 수.
* `private`/`default` 멤버는 **상속은 되지만** 자손에서 **직접 접근 불가**.

### 포함(Composition) vs 상속

* **is-a** → 상속 (예: `SportsCar is a Car`)
* **has-a** → 포함 (예: `Circle has a Point`)
* 자바는 **단일 상속**만 허용 (다중 상속 X) → 복잡성/모호성 방지. 다중 기능은 **상속+포함** 조합으로 해결.

### 최상위 조상

* 모든 클래스의 최상위는 **`java.lang.Object`**.

---

## 2. 오버라이딩 (Overriding)

### 정의

* **상속받은 메서드의 구현(내용)** 을 **자손에 맞게 재정의**하는 것.

### 성립 조건 (선언부 완전 동일)

* **메서드 이름/매개변수/반환타입** 동일.
* **접근 제어자**: 조상보다 **좁아질 수 없음** (public ≥ protected ≥ default ≥ private).
* **예외**: 조상보다 **더 넓은(상위) 예외**를 던질 수 없음.
* **static ↔ 인스턴스**로 변경 불가 (오버라이딩 아님). 같은 이름의 static은 **숨김(hiding)**.

### `super`

* 자손에서 **조상 멤버/메서드** 접근 시 사용 (`super.x`, `super.method()`).
* 오버라이딩 메서드에서 **조상 구현 포함** 시 유용: `return super.getLocation() + ...`.

### `super()` (조상 생성자 호출)

* 자손 생성자 **첫 줄**에서만 호출 가능. 미호출 시 컴파일러가 `super();` 자동 삽입.
* 조상에 **기본 생성자 없으면** 명시적으로 `super(args...)` 호출 필요.

---

## 3. 패키지 & import

### 패키지

* **클래스들의 묶음 = 디렉터리** 구조. 풀네임 = `패키지명.클래스명`.
* 소스 최상단에 **한 번만** 선언: `package com.example.app;`
* 컴파일 시 `javac -d . Foo.java` 로 디렉터리 자동 생성.

### import

* 다른 패키지의 클래스를 **패키지명 없이** 쓰기 위한 선언.
* 위치: `package` 아래, **여러 번** 가능.
* 형식: `import java.util.List;` 또는 `import java.util.*;` (하위패키지까지는 X).
* `java.lang`은 **자동 임포트**.

### static import

* static 멤버를 **클래스명 없이** 사용:

    * `import static java.lang.Math.*;` → `random()`
    * `import static java.lang.System.out;` → `out.println()`

---

## 4. 제어자 (Modifiers)

### 분류

* **접근 제어자**: `public`, `protected`, `default`, `private`
* **그 외**: `static`, `final`, `abstract`, `native`, `transient`, `synchronized`, `volatile`, `strictfp`

### 사용 가능 위치 요약

| 대상    | 접근 제어자                           | 기타                      |
| ----- | -------------------------------- | ----------------------- |
| 클래스   | public, default                  | final, abstract         |
| 메서드   | public/protected/default/private | final, abstract, static |
| 멤버 변수 | public/protected/default/private | final, static           |
| 지역 변수 | (없음)                             | final                   |

### 빈출 제어자 요약

* **static**: 클래스(공용) 멤버. 인스턴스 없이 사용 가능. *static 메서드에서는 인스턴스 멤버 직접 사용 불가*.
* **final**:

    * 클래스: 상속 금지
    * 메서드: 오버라이딩 금지
    * 변수: 상수 (인스턴스 변수는 **생성자에서 1회 초기화** 가능)
* **abstract**:

    * 메서드: 본문 없는 **추상 메서드**
    * 클래스: **미완성 설계도** (인스턴스 생성 불가)

### 주의할 조합

1. `static` + `abstract` (메서드) → 몸통 O / 몸통 X
2. `abstract` + `final` (클래스) → 상속 필수 / 확장 불가
3. `private` + `abstract` (메서드) → 상속 필수 / 접근 불가
4. `private` + `final` (메서드) → 의미 중복, 일반적으로 **불필요**

### 접근 제어자별 범위

* **public** > **protected** > **default** > **private**
* **캡슐화** 목적:

    * 데이터 보호(유효성 유지, 민감 데이터 보호)
    * 내부 구현 은닉(복잡성 감소)
* *게터/세터* 패턴: `getXxx() / setXxx()` 로 간접 접근.

### 생성자의 접근 제어자 (싱글턴 예)

* **private 생성자** → 외부에서 인스턴스화 금지.
* `public static getInstance()` 로 단일 인스턴스 제공.
* 상속 금지를 명확히 하려면 **`final` 클래스**.

---

## 5. 다형성 (Polymorphism)

### 정의

* **한 타입의 참조변수**가 **여러 타입의 인스턴스**를 가리킬 수 있는 성질.
* 자바: **조상 타입 참조**로 **자손 인스턴스** 참조 가능. (반대는 불가)

### 멤버 해석 규칙

* **필드(변수)**: 참조변수의 **타입** 기준으로 접근 범위 결정.
* **메서드**: **런타임 실제 인스턴스**의 오버라이딩 메서드가 호출(동적 바인딩).

### 형변환

* 상속 관계에서만 가능.
* **업캐스팅**(자손→조상): **생략 가능**.
* **다운캐스팅**(조상→자손): **명시 필요** + 안전하게 `instanceof`로 확인 후 수행.
* 형변환은 **참조변수의 타입만** 바꿈 (인스턴스 자체 변화 X).

### 매개변수의 다형성

* 메서드 파라미터를 조상 타입으로 선언하면, **모든 자손 타입**을 한 메서드로 처리 가능.

    * 예: `void buy(Product p)` ← `Tv/Computer/Audio` 모두 수용.

### 이종 객체 배열

* 공통 조상을 타입으로 한 **배열/컬렉션**에 서로 다른 자손 타입 저장 가능.

    * 예: `Product[] items = { new Tv(), new Computer(), new Audio() };`
    * 동적 배열 컬렉션: `ArrayList`, (레거시) `Vector` 등.

---

### Ch. 1 ~ 5 예시 모음

```java
// 1) 상속 vs 포함
class Shape {}
class Point { int x, y; }
class Circle extends Shape { Point center = new Point(); int r; } // is-a + has-a

// 2) 오버라이딩 + super
class Point2 { int x, y; String loc(){ return "x:"+x+", y:"+y; } }
class Point3D extends Point2 { int z; @Override String loc(){ return super.loc()+", z:"+z; } }

// 3) static import 예
import static java.lang.Math.*; // random(), sqrt() 등 바로 사용

// 4) 접근 제어자와 캡슐화
class Time { private int hour; public void setHour(int h){ if(0<=h && h<24) hour=h; } }

// 5) 다형성/형변환
class Car { void drive(){} }
class FireEngine extends Car { void water(){} }
Car c = new FireEngine(); // upcast
if (c instanceof FireEngine fe) { fe.water(); } // Java 16+ 패턴매칭
```

---

## 6. 추상 클래스 (Abstract Class)

### 개념

* **미완성 설계도**: 하나 이상 **추상 메서드**를 포함할 수 있는 클래스.
* **인스턴스 생성 불가**, **상속**으로 자손에서 완성.
* 추상 메서드가 없어도 `abstract` 지정 시 **인스턴스화 제한** 목적의 추상 클래스가 됨.

### 추상 메서드

* 형식: `abstract 반환타입 메서드명(매개변수…);` (**구현부 없음**)
* 자손은 **모두 구현(오버라이딩) 필수**. 하나라도 미구현이면 자손도 `abstract`.

### 추상화 vs 구체화

* **추상화**: 여러 클래스의 **공통 요소를 상위로 끌어올림** → 공통 조상 정의.
* **구체화**: 계층을 **내려갈수록 기능 추가/세분화**.

### 사용 팁

* “빈 몸통 메서드” 대신 **진짜 추상 메서드**로 강제 → 구현 누락 방지.
* 공통 필드/기본 동작은 추상 클래스에, 변화점은 **추상 메서드**로 열어두기.

```java
abstract class Product { int price; int bonusPoint; /* 공통 */ }
class Tv extends Product { /* 구체화 */ }
```

---

## 7. 인터페이스 (Interface)

### 개념

* **추상화 정도 최고**: (기본) **추상 메서드 + 상수**만. (JDK 8+) **default/static 메서드** 허용.
* **구현(implements)** 으로 능력(…able)을 부여.

### 문법 요약

```java
interface X {
  // (생략해도) 모두 public static final
  int CONST = 1;
  // (생략해도) 모두 public abstract
  void doIt();
  // (JDK 8+) 기본 구현
  default void opt() {}
  // (JDK 8+) 유틸리티
  static void util() {}
}

class Impl implements X { public void doIt() { /* 구현 */ } }
```

### 상속/구현 규칙

* 인터페이스 **끼리 다중 상속 가능**: `interface A extends B, C {}`
* 클래스는 **extends 1개 + implements N개** 가능: `class C extends P implements A, B {}`
* **접근 제어자 주의**: 인터페이스 메서드는 암묵적으로 `public`; 구현 시 **반드시 public** 으로 오버라이드.

### 다형성 활용

* **참조/매개변수/반환 타입**으로 인터페이스 사용 → 구현 교체에 유연.

```java
X make() { return new Impl(); }
void use(X x) { x.doIt(); }
```

### default/static 메서드와 충돌 규칙

* `default` 메서드 추가로 **기존 구현체 변경 없이** 기능 확장.
* 충돌 해결:

    1. **여러 인터페이스 default 충돌** → 구현 클래스에서 **오버라이딩 필수**.
    2. **클래스의 메서드 vs default** → **클래스 우선**, default 무시.

### 팩토리 패턴 예시

```java
interface Parseable { void parse(String file); }
class XMLParser implements Parseable { public void parse(String f){ /*...*/ } }
class HTMLParser implements Parseable { public void parse(String f){ /*...*/ } }
class ParserManager {
  static Parseable getParser(String type){
    return "XML".equals(type) ? new XMLParser() : new HTMLParser();
  }
}
```

---

## 8. 내부 클래스 (Inner Class)

### 개념 & 장점

* **클래스 내부의 클래스**로 외부와 **긴밀한 관계** 표현.
* 외부 멤버 접근 용이, **캡슐화/구현은닉**.

### 종류와 위치별 성격

| 종류                | 선언 위치         | 성격/접근                                    |
| ----------------- | ------------- | ---------------------------------------- |
| **인스턴스 내부 클래스**   | 외부 **멤버 영역**  | 외부의 **인스턴스 멤버처럼** 동작                     |
| **static 내부 클래스** | 외부 **멤버 영역**  | 외부의 **static 멤버처럼**, **static 멤버 보유 가능** |
| **지역 내부 클래스**     | **메서드/블록 내부** | 선언된 **블록 내부에서만** 사용                      |
| **익명 클래스**        | **선언+생성 동시**  | 이름/생성자 없음, **일회용** 구현체                   |

### 핵심 규칙

* **static 멤버**는 **static 내부 클래스**에서만 선언 가능(단, `final static` 상수는 예외).
* 내부 클래스는 외부의 `private` 멤버에도 접근 가능.
* 지역 내부 클래스는 감싸는 블록의 **지역 변수 중 ‘상수’(JDK 8+: effectively final)** 만 접근.

### 생성/접근 패턴

```java
class Outer { int iv; static int sv;
  class Inner { void f(){ System.out.println(iv); } }
  static class SInner { void g(){ System.out.println(sv); } }
  void m(){ class Local{ } new Local(); }
}

Outer o = new Outer();
Outer.Inner in = o.new Inner();      // 인스턴스 내부 클래스
Outer.SInner si = new Outer.SInner();// static 내부 클래스
```

### 익명 클래스 예

```java
btn.addActionListener(new ActionListener(){
  public void actionPerformed(ActionEvent e){ /* ... */ }
});
```
