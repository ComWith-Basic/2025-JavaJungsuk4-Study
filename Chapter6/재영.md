# Chapter 06: 객체지향 프로그래밍 I

## 1. 객체지향언어

### 역사와 기본 개념

* 실제 세계를 **객체(사물/개념)** 로 보고, 사건은 **객체 간 상호작용**으로 본다.
* 현실의 **속성**과 **기능**을 **데이터(변수)** 와 **함수(메서드)** 로 옮겨와 가상세계를 구현.
* 핵심 개념: **추상화 · 캡슐화 · 상속 · 다형성**.

### 주요 특징

1. **재사용성** 높음
2. **유지보수성** 우수
3. **신뢰성** 향상(정보은닉, 중복 제거)

> 먼저 기능을 완성하고, 이후 점진적으로 객체지향적으로 리팩터링하자.

---

## 2. 클래스와 객체

### 정의와 용도

* **클래스**: 객체의 설계도(정의). 객체 생성에 사용.
* **객체**: 실제 메모리에 존재하는 데이터/행위의 묶음.
* 관계: 설계도(클래스) → 제품(객체).

### 객체 vs 인스턴스

* **인스턴스화**: 클래스로부터 객체를 만드는 과정.
* **인스턴스**: 특정 클래스에서 생성된 객체(어느 클래스로부터인가를 강조).

### 구성요소(멤버)

* **속성**: 멤버변수/필드/상태
* **기능**: 메서드/행위

```java
class TV {
    String color;   // 속성
    boolean power;  // 속성
    int channel;    // 속성

    void power() { power = !power; }      // 기능
    void channelUp() { channel++; }       // 기능
    void channelDown() { channel--; }     // 기능
}
```

### 인스턴스 생성/사용 요약

```java
Tv t = new Tv(); // 생성
t.channel = 7;   // 속성 사용
t.channelDown(); // 기능 호출
System.out.println(t.channel);
```

> 인스턴스는 **참조변수**를 통해서만 접근. 타입은 일치해야 함.

### 객체 배열

```java
Tv[] tvs = new Tv[3];
for (int i = 0; i < tvs.length; i++) tvs[i] = new Tv();
```

### 클래스의 또 다른 의미

* **데이터+함수의 결합**(구조체의 확장)
* **사용자 정의 타입**: 관련 데이터를 하나의 타입으로 묶어 다룸

---

## 3. 변수와 메서드

### 변수의 종류(선언 위치 기준)

* **클래스 변수**: `static` 멤버. 클래스 로딩 시 1회 생성, 공용 저장공간.
* **인스턴스 변수**: 각 인스턴스마다 독립 저장공간.
* **지역 변수**: 블록/메서드 내부, 블록을 벗어나면 소멸.

```java
class Variables {
    int iv;          // 인스턴스 변수
    static int cv;   // 클래스 변수
    void m() { int lv = 0; } // 지역 변수
}
```

### 클래스변수 vs 인스턴스변수

```java
class Card {
    String kind;  // 인스턴스 속성
    int number;   // 인스턴스 속성
    static int width = 100;   // 클래스 공통 속성
    static int height = 250;  // 클래스 공통 속성
}
// 권장 접근: Card.width (인스턴스가 아닌 클래스명으로)
```

### 메서드 개요

* **정의**: 특정 작업을 수행하는 문장들의 묶음(입력→처리→반환).
* **이점**: 재사용/중복 제거/구조화.

**선언과 구현**

```java
반환타입 이름(매개변수...) { ... }
int add(int a, int b) { return a + b; }
```

* **매개변수**: 입력을 받는 변수 목록(개수·순서·타입 일치 필요)
* **반환타입**: 없으면 `void`
* **return**: `void`가 아니면 반드시 필요(단일 값 반환)

### 메서드 호출

```java
printAll();
int r = add(3, 5);
```

* 같은 클래스 내 메서드는 참조변수 없이 호출 가능.
* `static` 메서드는 인스턴스 멤버를 직접 사용할 수 없음.

### JVM 메모리 구조 핵심

* **Method Area**: 클래스 정보, `static` 변수
* **Heap**: 인스턴스/인스턴스 변수
* **Call Stack**: 각 메서드 호출 프레임(지역/매개변수, 중간결과)

### 기본형 vs 참조형 매개변수

* **기본형**: 값 복사(원본 불변)
* **참조형**: 주소 복사(대상 변경 가능)

### 참조형 반환

```java
static Data copy(Data d){ Data t=new Data(); t.x=d.x; return t; }
```

### 재귀(Recursive)

* 자기 자신을 호출하는 메서드. **종료 조건** 필수. 성능은 반복문이 유리한 경우 多.

```java
static int fact(int n){ if(n<=0||n>12) return -1; return n==1?1:n*fact(n-1); }
```

### static 메서드 vs 인스턴스 메서드

* 인스턴스 상태를 쓰지 않으면 **static** 권장(호출 비용↓)
* 클래스 메서드에서 인스턴스 멤버 직접 접근 **불가**

---

## 4. 오버로딩(overloading)

### 정의

* 한 클래스 내 **같은 이름**의 메서드를 **매개변수 목록(개수/타입/순서)** 으로 구분하여 여러 개 정의.
* **반환 타입만** 다른 것은 오버로딩이 아님.

### 예

```java
void println()
void println(int x)
void println(double x)
void println(String x)
...
```

* 적합한 시그니처가 **컴파일 시** 선택됨.

### 주의/패턴

```java
int  add(int a,int b);
long add(long a,long b);
long add(int[] a);
// (이름만 다른 매개변수, 반환타입만 다른 경우는 X)
```

### 가변인자(varargs)

* 선언: `타입... 이름` (항상 **마지막** 매개변수)

```java
String join(String delim, String... parts)
```

* 내부적으로 **배열 생성** 비용 발생 → 꼭 필요할 때만 사용.
* varargs 오버로딩은 **모호성** 주의.

---

## 5. 생성자(constructor)

### 정의/특징

* 인스턴스 생성 시 호출되는 **초기화 메서드**(반환값 없음, 이름=클래스명).
* 인스턴스 생성: `new` → **생성자 호출** → 참조 대입.

### 기본 생성자

* 생성자를 하나도 정의하지 않으면 컴파일러가 `클래스명(){}` 를 자동 추가.

### 매개변수 있는 생성자

```java
class Car{
  String color, gearType; int door;
  Car(){ }
  Car(String c,String g,int d){ color=c; gearType=g; door=d; }
}
```

### 생성자 체이닝: `this()` / `this`

```java
Car(){ this("white","auto",4); }
Car(String c){ this(c,"auto",4); }
Car(String c,String g,int d){ this.color=c; this.gearType=g; this.door=d; }
// this : 인스턴스 자신 참조 / this() : 같은 클래스 다른 생성자 호출(첫 줄에서만)
```

### 복사 생성자 패턴

```java
Car(Car other){ this(other.color, other.gearType, other.door); }
```

---

## 6. 변수의 초기화

### 개념/기본값

* 변수를 **처음 값으로 설정**하는 것.
* **멤버변수/배열**은 기본값으로 자동 초기화, **지역변수**는 사용 전 **반드시** 초기화.

**기본값 요약**

* boolean: `false` / char: `\u0000`
* byte/short/int: `0` / long: `0L`
* float: `0.0f` / double: `0.0`
* 참조형: `null`

### 초기화 방법

1. **명시적 초기화**: 선언과 동시에 대입
2. **초기화 블록**: `static {}`(클래스 1회), `{}`(인스턴스 매번)
3. **생성자**: 인스턴스별 초기값 부여

### 초기화 순서

* **클래스 변수**: 기본값 → 명시적 → 클래스 초기화 블록
* **인스턴스 변수**: 기본값 → 명시적 → 인스턴스 초기화 블록 → 생성자

```java
class InitTest{
  static int cv = 1; // 명시적
  int iv = 1;        // 명시적
  static { cv = 2; } // 클래스 초기화 블록
  { iv = 2; }        // 인스턴스 초기화 블록
  InitTest(){ iv = 3; } // 생성자
}
```

### 예: 공통 초기화 로직의 블록화

```java
class Product{
  static int count = 0; // 총 개수
  int serialNo;
  { ++count; serialNo = count; } // 모든 생성자 공통 처리
  Product(){}
}
```

### 예: this()/this 활용

```java
class Document{
  static int count=0; String name;
  Document(){ this("제목없음" + ++count); }
  Document(String name){ this.name=name; System.out.println("문서 " + name + " 생성"); }
}
```
