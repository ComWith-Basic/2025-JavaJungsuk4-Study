# 자바의정석
## Chapter 6. 객체지향 프로그래밍 1
---

## 1. 객체지향 프로그래밍이란?

프로그램을 다수의 **객체(Object)** 들의 집합으로 보고, 이 객체들이 서로 **상호작용**하며 동작하도록 만드는 프로그래밍 기법이다. 
현실 세계의 사물이나 개념을 객체로 모델링하여 생각하기 때문에, 더 직관적이고 효율적으로 복잡한 프로그램을 설계할 수 있다.

### 주요 특징

1.  **코드의 재사용성 (Reusability)**
    * 이미 만들어진 클래스를 상속받거나 포함하여 새로운 클래스를 쉽게 만들 수 있다. 즉, 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2.  **코드의 관리 용이성 (Maintenance)**
    * 관련된 데이터(변수)와 기능(메서드)을 하나의 클래스 안에 묶어서 관리하므로, 코드 관의 관계를 통해 큰 힘을 안 들이고도 쉽게 코드 변경이 가능하다.
3.  **높은 신뢰성 (Reliability)**
    * 제어자(modifier)를 통해 외부로부터의 데이터를 보호하고, 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

---

## 2. 클래스와 객체

### 2.1 클래스와 객체의 정의

* **클래스 (Class)** 
    * 객체를 정의해 놓은 **설계도** 또는 **틀(template)** 이다.
    * 클래스는 객체를 생성하는 데 사용되며, 객체가 가질 **속성(상태)** 과 **기능(행위)** 을 정의한다.
    * 예: `붕어빵 틀`, `자동차 설계도`
    * 클래스: 객체를 정의해놓은 것
    * 클래스의 용도: 객체를 생성하는데 사용함.

* **객체 (Object)** 
    * 클래스라는 설계도를 바탕으로 메모리에 **실제로 생성된 실체(instance)** 이다.
    * 자신만의 고유한 속성 값을 가지며, 클래스에 정의된 기능을 수행할 수 있다.
    * 예: `팥 붕어빵`, `내 빨간색 포르쉐 자동차`

> **객체와 인스턴스**
> 객체는 모든 인스턴스를 대표하는 포괄적인 의미이며, 인스턴스는 특정 클래스로부터 생성된 객체임을 강조하는 표현이다.
> "책상은 객체다"와 "이 책상은 책상 클래스의 인스턴스다"는 같은 의미로 보면 된다.

### 2.2 객체의 구성요소

객체는 **속성(Property)**과 **기능(Function)**, 이 두 가지로 구성되는데, 이들을 클래스의 **멤버(member)**라고 한다.

* **속성 (Property)**: **멤버 변수(member variable)**, 필드(field), 상태(state) 라고도 함.
* **기능 (Function)**: **메서드(method)**, 행위(behavior)라고도 함.

```java
// Tv 클래스 (설계도)
class Tv {
    // 속성 (멤버 변수)
    String color;      
    boolean power;      
    int channel;        

    // 기능 (메서드)
    void power() {
      power = !power; }  
    void channelUp() {
      channel++; }
    void channelDown() {
      channel--; } 
}
```


### 2.3 인스턴스의 생성과 사용
클래스를 정의한 뒤, new 연산자를 통해 인스턴스를 생성하고 참조 변수를 통해 사용할 수 있다.

``` Tv t = new Tv(); ```

Tv t; : Tv 클래스 타입의 **참조 변수 t**를 선언한다. 이 변수는 앞으로 생성될 Tv 인스턴스의 메모리 주소를 저장할 공간이다.

new Tv(); : new 연산자가 Tv 클래스의 인스턴스를 힙(Heap) 메모리 영역에 생성한다.
이때 멤버 변수들은 각 타입의 기본값(null, false, 0)으로 자동 초기화되고, 생성된 인스턴스의 메모리 주소를 반환한다.

= : new 연산자가 반환한 주소값을 참조 변수 t에 저장한다. 이제 t를 통해 힙에 있는 인스턴스에 접근할 수 있다.

#### 인스턴스 사용하기

참조 변수와 . 연산자를 사용하여 인스턴스의 멤버(변수, 메서드)에 접근한다.

```Java

public class TvTest {
    public static void main(String[] args) {
        Tv t1 = new Tv();  // Tv 인스턴스 생성
        Tv t2 = new Tv();  // 다른 Tv 인스턴스 생성

        System.out.println("t1의 channel 값: " + t1.channel); // 0
        System.out.println("t2의 channel 값: " + t2.channel); // 0

        t1.channel = 7; 

        System.out.println("t1의 channel 값: " + t1.channel); // 7
        System.out.println("t2의 channel 값: " + t2.channel); // 0

        t2 = t1; // t1이 가리키는 주소값을 t2에 복사
        System.out.println("t1의 channel 값: " + t1.channel); // 7
        System.out.println("t2의 channel 값: " + t2.channel); // 7 (이제 t1과 t2는 같은 인스턴스를 가리킴)
    }
}
```

### 2.4 클래스의 또 다른 정의
(객체지향이론 관점) 클래스는 객체를 생성하기 위한 틀이며, 클래스는 속성과 기능으로 정의되어있다.
**(프로그래밍관점)** 다른 의미로 해석할 수 있다.

1. 변수 - 하나의 데이터를 저장할 수 있는 공간
2. 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 - 데이터와 함수의 결합 (구조체 + 함수)

---

## 3. 변수와 메서드️
### 3.1 변수의 종류
변수는 선언된 위치에 따라 세 가지 종류로 구분한다.

종류	선언 위치	생성 시점	특징
클래스 변수 (Class Variable)	클래스 영역 (static 키워드)	클래스가 메모리에 로딩될 때	모든 인스턴스가 공유하는 변수이다. 인스턴스 생성 없이 /*클래스명.변수명*/ 으로 접근이 가능하다.
인스턴스 변수 (Instance Variable)	클래스 영역	인스턴스가 생성될 때	각 인스턴스마다 독립적인 저장 공간을 가진다.
지역 변수 (Local Variable)	메서드, 생성자, 초기화 블록 내부	선언문이 수행될 때	선언된 블록 {} 내에서만 사용 가능하며, 사용 전 반드시 초기화 필요하다.

``` Java

class Card {
    // 인스턴스 변수
    String kind;
    int number;

    // 클래스 변수 (static)
    static int width = 100;
    static int height = 250;
}
```
width와 height를 static으로 선언하면, 카드를 100장 만들어도 width와 height를 위한 메모리 공간은 단 하나만 생성되어 모든 인스턴스가 공유한다.

### 3.2 메서드 (Method)
특정 작업을 수행하는 코드의 묶음이다. 메서드를 사용하면 코드의 중복을 줄이고, 재사용성을 높이며, 프로그램을 구조화하여 관리하기 편하다.
메서드는 특정 작업을 수행하는 문장들을 하나로 묶은 것으로, function과 유사하다고 보면 된다.
<img width="924" height="322" alt="메서드" src="https://github.com/user-attachments/assets/3721db68-f571-446a-88ac-010590c999fa" />


메서드 선언부 (Method Declaration): 반환타입 메서드이름 (매개변수타입 변수명, ...)

메서드 구현부 (Method Body): {} 블록 안에 실제 동작하는 코드를 작성한다.

```Java

// 선언부
int add(int x, int y) {
    // 구현부
    int result = x + y;
    return result; // 결과를 반환
}
```
<img width="904" height="363" alt="장점" src="https://github.com/user-attachments/assets/eaff9958-3faf-417f-907b-52b5fff8a2fc" />


### 3.3 JVM 메모리 구조와 메서드 호출
메서드가 호출되면 **호출 스택(Call Stack)**이라는 메모리 공간에서 실행된다.

메서드가 호출되면, 호출 스택에 해당 메서드를 위한 스택 프레임이 생성된다.

스택 프레임에는 매개변수, 지역 변수, 연산 중간 결과 등이 저장된다.

메서드 실행이 끝나면, 해당 스택 프레임은 호출 스택에서 제거된다.

호출 스택의 가장 위에 있는 스택 프레임이 현재 실행 중인 메서드이다.

### 3.4 기본형 매개변수 vs 참조형 매개변수
메서드에 인자를 전달할 때, 타입에 따라 동작 방식이 다르다.

기본형 매개변수 (Primitive Type): 값(Value)이 복사된다. 메서드 내에서 매개변수 값을 변경해도, 호출한 쪽의 원본 변수에는 아무런 영향을 주지 않는다. **(Call by Value)**

참조형 매개변수 (Reference Type): 주소값(Address)이 복사된다. 메서드 내에서 매개변수를 통해 객체의 속성을 변경하면, 원본 객체의 속성도 함께 변경된다.

### 3.5 재귀 호출 (Recursive Call)
메서드 내부에서 자기 자신을 다시 호출하는 기법이다. 반복문과 유사한 효과를 내지만, 코드가 더 간결하고 직관적인 장점이 있다. (다 그렇지 않음. 비고 참고)

비고: 재귀 호출에는 반드시 종료 조건이 있어야 한다. 그렇지 않으면 무한히 자신을 호출하다가 StackOverflowError가 발생하며 오류가 발생하며 프로그램이 중단된다.

```Java

long factorial(int n) {
    // 종료 조건
    if (n <= 0 || n > 20) return -1; // 유효성 검사
    if (n == 1) return 1;

    // 재귀 호출
    return n * factorial(n - 1);
}
```

---

### 4. 오버로딩 (Overloading)
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 말한다. 보통 '메서드 오버로딩' or '오버로딩' 이라고 부른다.

#### 오버로딩의 조건:

메서드 이름이 같아야 한다.

매개변수의 개수 또는 타입이 달라야 한다. (매개변수 이름은 상관 없음)

반환 타입은 오버로딩 조건에 해당하지 않는다.

```Java

class Calculator {
    int add(int a, int b) {
      return a + b;
    }
    long add(long a, int b) {
      return a + b;
      }
    long add(int a, long b) {
      return a + b;
    }
    long add(long a, long b) {
      return a + b;
    }
    int add(int[] a) { /* 배열의 모든 요소의 합을 반환 */ }
}
```
#### 관련 추가 예시 (println 메서드 호출 시, 매개변수로 넘어오는 타입에 맞는 오버로딩된 메서드가 선택되어 실행된다.)
``` Java
void println()
void println(boolean x)
void println(char x)
void println(int x)
void println(long x)
```
#### 오버로딩 장점
메서드가 만약 변수처럼 이름만으로 구별한다고 하면, 

---
### 5. 생성자 (Constructor)
인스턴스가 생성될 때 호출되어 인스턴스 변수를 초기화하는 역할을 하는 특별한 메서드이다.
<img width="360" height="178" alt="생성자" src="https://github.com/user-attachments/assets/b6aa0906-087e-4a39-9e79-619bf766fd30" />
<img width="694" height="366" alt="생성자2" src="https://github.com/user-attachments/assets/63e30290-9bc9-403e-9797-c4c73da1bf5d" />

생성자의 조건:

이름이 클래스 이름과 같아야 한다.

리턴 값이 없다 (void 키워드를 사용하지 않는다).

기본 생성자 (Default Constructor): 매개변수가 없는 생성자. 만약 클래스에 생성자가 하나도 정의되어 있지 않다면, 컴파일러가 자동으로 클래스명() {} 형태의 기본 생성자를 추가한다.

#### this 와 this()의 차이
this: 인스턴스 자기 자신을 가리키는 참조 변수. 매개변수 이름과 인스턴스 변수 이름이 같을 때 구분하기 위해 사용된다.
this(): 같은 클래스의 다른 생성자를 호출할 때 사용한다. 생성자의 첫 줄에서만 호출할 수 있으며, 코드 중복을 줄이는 데 매우 유용하다.

```Java

class Car {
    String color;
    String gearType;
    int door;

    // 기본 생성자. this()를 이용해 다른 생성자 호출
    Car() {
        this("white", "auto", 4);
    }

    Car(String color) {
        this(color, "auto", 4);
    }

    // this를 이용해 인스턴스 변수 초기화
    Car(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```
---
### 6. 변수의 초기화
변수를 선언하고 처음으로 값을 저장하는 것이다.

멤버 변수 (클래스/인스턴스): 초기화하지 않아도 각 타입의 기본값으로 자동으로 초기화된다.

지역 변수: 사용하기 전에 반드시 수동으로 초기화해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

#### 초기화 순서
클래스 변수: 기본값 → 명시적 초기화 → 클래스 초기화 블록

인스턴스 변수: 기본값 → 명시적 초기화 → 인스턴스 초기화 블록 → 생성자

명시적 초기화: 변수 선언과 동시에 값을 할당하는 것. (int iv = 10;)

초기화 블록:

클래스 초기화 블록: static { ... } - 클래스가 처음 메모리에 로딩될 때 딱 한 번 실행된다.

인스턴스 초기화 블록: { ... } - 인스턴스가 생성될 때마다, 생성자보다 먼저 실행된다.

```Java

class Product {
    static int count = 0; // 명시적 초기화 (클래스 변수)
    int serialNo = 0;     // 명시적 초기화 (인스턴스 변수)

    // 인스턴스 초기화 블록
    // 모든 생성자에서 공통적으로 수행될 코드
    {
        ++count;
        serialNo = count;
    }

    // 생성자
    public Product() {}
}
```
