# Chapter 06. 객체지향 프로그래밍 1

## 1.1 객체지향 언어의 역사
* 객체지향의 기본 개념 : 실제 세계는 **사물(객체)**로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 모든 사물간의 **상호작용**이다.
* 객체지향이론은 **상속, 캡슐화, 추상화** 개념을 중심으로 점차 구체적으로 발전되었다.

## 1.2 객체지향언어
* 1. 코드의 재사용성이 높다.
    > 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
* 2. 코드의 관리가 용이하다.
    > 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
* 3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
    > 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

## 2. 클래스와 객체

### 2.1 클래스와 객체의 정의와 용도
* 클래스란?  
객체를 정의한 것, 객체의 설계도
 > **클래스의 정의** 클래스란 객체를 정의해 놓은 것  
 > **클래스의 용도** 클래스는 객체를 생성하는데 사용된다.  
 * 객체의 정의는 **실제로 존재하는 것**  
 > **객체의 정의** 실제로 존재하는 것. 사물 또는 개념
 > **객체의 용도** 객체가 가지고 있는 기능과 속성에 따라 다름  
 > **유형의 객체** 책상, 의자, 자동차, TV와 같은 사물
 > **무형의 객체** 수학공식, 프로그램 에러와 같은 논리나 개념념

 ### 2.2 객체와 인스턴스  
 * 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
 > 클래스 ->(인스턴스화) 인스턴스(객체)

 ### 2.3 객체의 구성요소 - 속성과 기능
 * 객체 - 속성 + 기능  
 객체가 갖고 있는 속성과 기능을 그 객체의 맴버라고 한다.
 > **속성** 멤버 변수, 특성, 필드, 상태
 > **기능** 메서드, 함수, 행위

 ## 2.4 인스턴스의 생성과 사용

 * Tv클래스를 선언한 것은 **TV설계도**를 작성한 것에 불과하므로, **TV인스턴스**를 생성해야 제품(Tv)을 사용할 수 있다.

 ```
 클래스명 변수명;   // 클래스의 객체를 참조하기 위한 참조 변수 (리모컨) 를 선언
 변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조 변수에 저장 (연결)

 Tv t;  // Tv클래스 타입의 참조 변수 t를 선언
 t = new Tv();  // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
 ```

 * 예제 6-1
 ```java
 class Tv {
    //Tv의 속성(멤버변수)
    String color;
    boolean power;
    int channel;

    // Tv의 기능(메서드)
    void power() { power = !power; }
    void channelUp() { ++ channel; }
    void channelDown() { --channel; }
 }

 class TvEx {
    public static void main(String args[]) {
        Tv t;
        t = new Tv();
        t.channel = 7;
        t.channelDown();
        System.out.println("현재 채널은" + t.channel + " 입니다.");
    }
 }
 ```

 * 1. Tv.t;  
 Tv클래스 타입의 참조변수 t를 선언한다. 메모리에 참조 변수 t를 위한 공간이 마련된다.
 * 2. t = new Tv();  
 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다.
* 3. t.channel = 7;  
참조 변수 t에 저장된 주소에 있는 인스턴스의 멤버 변수 channel에 7을 저장한다.  
* 4. t.channelDown();  
참조 변수 t가 참조하고 있는 Tv인스턴스의 channelDown메서드를 호출한다.(7->6)  
* 5. System.out.println("현재 채널은" + t.channel + "입니다.);  
참조 변수 t가 참조하고 있는 Tv인스턴스의 멤버 변수 channel에 저장되어 있는 값을 출력한다.

> **인스턴스는 참조 변수를 통해서만 다룰 수 있으며, 참조 변수의 타입은 인스턴스의 타입과 일치해야 한다.**  

### 2.6 클래스의 또 다른 정의
* 클래스 : 객체를 생성하기 위한 틀, 속성과 기능으로 정의되어 있음.  

>> 1.**변수** 하나의 데이터를 저장할 수 있는 공간  
>> 2. **배열** 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간  
>> 3. **구조체** 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간  
>> 4. **클래스** 데이터와 함수의 결합(구조체 + 함수)  

## 3.  변수와 메서드

### 3.1 선언위치에 따른 변수의 종류

```java
class MyClass
{
    int iv;
    static int cv;

    void method()
    {
        int lv = 0; //지역 변수
    }
}
```

* 1. 인스턴스 변수  
클래스 영역에 선언, 인스턴스를 생성할 때 만들어짐.  
* 2. 클래스 변수  
인스턴스 변수 앞에 static을 붙인 것이다. 인스턴스 변수와 달리, 클래스 변수는 모든 인스턴스가 저장 공간(변수)을 공유한다.
* 3. 지역 변수  
메서드 내에 선언되며 메서드 내에서만 사용 가능하며, 메서드가 호출되면 만들어졌다가 메서드가 종료되면 소멸된다.  

### 3.2 클래스 변수와 인스턴스 변수   

```java
class Card {
    String kind; //무늬
    int number; //숫자

    static int width = 100; //폭
    static int height = 250; // 높이
}
```

```java
class CardEx {
    public static void main(String args[]) {
        System.out.println("Card.width  = " + Card.width);
        System.out.println("Card.height = " + Card.height);

        Card c1 = new Card();
        c1.kind = "Heart";
        c1.number = 7;

        Card c2 = new Card();
        c2.kind = "Spade";
        c2.number = 4;

        System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")" );
        System.out.println("c2는 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")" );
        System.out.println("c1의 width와 height를 각각 50, 80으로 변경합니다.");
        c1.width = 50;
        c1.height = 80;

        System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")" );
        System.out.println("c2는 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")" );
    }
}

class Card {
    String kind ;
    int number;
    static int width  = 100;
    static int height = 250;
}
```
>> **인스턴스 변수** 는 인스턴스가 생성될 때마다 생성되므로 **다른 값**을 갖지만, **클래스 변수**는 모든 인스턴스가 하나의 저장공간을 공유하므로, **같은 값**을 갖는다.  

### 3.3 메서드  

* **메서드**는 특정 작업을 수행하는 문장들을 하나로 묶은 것이다.  
>> 메서드를 사용하는 이유
>> 1. 높은 재사용성
>> 2. 중복된 코드의 제거
>> 3. 프로그램의 구조화  

### 3.4 메서드의 선언과 구현  

* 메서드 선언부  
메서드 선언부는 '메서드의 이름', '매개변수 선언', '반환타입'으로 구성되어 있음.
```java
int add (int x, int y) {
    int result = x + y;
    return result;
}  
```
* 매개변수 선언  
```java
int add (int x, int y) {...}
```
* 매서드의 이름  
알 수 있게만 의미있게 지어주자.  
* 반환타입  
반환값(return value)의 타입을 적는다.  
```java
void print99danAll() {
    for (int i = 1; i <= 9; i++) {
        for (int j = 2; j <= 9; j++) {
            System.out.print(j+"*"+i+"="+(j*i)+" ");
        }
        System.out.println();
    }
}
```
* 메서드의 구현부  
메서드 선언부 다음에 오는 괄호 {}를 메서드의 구현부라 한다.  
* return문  
void가 아닌 경우 반환값이 반드시 포함되어야 하며, 반환값을 호출한 메서드로 전달하는데, 이 값의 타입은 반환타입과 **일치하거나 자동 형변환이 가능한 것**이어야 한다.
* 지역 변수  
매서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드라면 같은 이름의 변수를 선언해도 된다. 매서드 내에 선언된 변수를 지역변수라고 한다.  

### 3.5 메서드의 호출  

```java
메서드이름(값1, 값2, ...) /// 메서드를 호출하는 방법
print99danAll(); // void print99danAll ()을 호출
int result = add(3, 5); //int add(int x, int y)를 호출하고, 결과를 result에 저장
```

* 예제제 6-6  
```java
class MyMathEx {
    public static void main(String args[]) {
        MyMath mm = new MyMath();
        long result1 = mm.add(5L, 3L);
        long result2 = mm.subtract(5L, 3L);
        long result3 = mm.multiply(5L, 3L);
        double result4 = mm.divide(5L, 3L);

        System.out.println("add(5L, 3L) = " + result1);
        System.out.println("subtract(5L, 3L) = " + result2);
        System.out.println("multiply(5L, 3L) = " + result3);
        System.out.println("divide(5L, 3L) = " + result4);
    }
}

class MyMath {
    long add(long a, long b) {
        long result = a+b;
        return result;
        //	return a + b;	// 위의 두 줄을 한 줄로 간단히 할 수 있다.
    }

    long subtract(long a, long b) { return a - b; }
    long multiply(long a, long b) { return a * b; }
    double divide(double a, double b) {
        return a / b;
    }
}
```

### 3.6 return문  
* return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 위에서 한번 언급했으므로 넘어가겠다.  

### 3.7 JVM의 메모리 구조  

* 1. 메서드 영역  
JVM은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.  
* 2. 힙(heap)  
인스턴스가 생성되는 공간.  
* 3. 호출 스택(call stack or execution stack)  
호출 스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.  

>> **메서드가 호출되면 수행에 필요한 메모리를 스택에 할당받는다.**
>> **메서드가 수행을 마치고나면 메모리가 스택에서 자동 제거된다.**
>> **호출 스택의 제일 위에 있는 메서드만 현재 실행 중인 메서드다.**  

### 3.8 기본형의 매개변수와 참조형 매개변수  

>> **기본형 매개변수** 변수의 값을 읽기만 할 수 있다.  
>> **참조형 매개변수** 변수의 값을 읽고 변경할 수 있다.

```java
class Data { int x; }

class PrimitiveParamEx {
    public static void main(String[] args) {
        Data d = new Data();
        d.x = 10;
        System.out.println("main() : x = " + d.x);

        change(d.x);
        System.out.println("After change(d.x)");
        System.out.println("main() : x = " + d.x);
    }

    static void change(int x) {  // 기본형 매개변수
        x = 1000;
        System.out.println("change() : x = " + x);
    }
}
```
여기서 change메서드에서 x의 값을 1000으로 변경  

```java
class Data2 { int x; }

class ReferenceParamEx {
    public static void main(String[] args) {
        Data2 d = new Data2();
        d.x = 10;
        System.out.println("main() : x = " + d.x);

        change(d);
        System.out.println("After change(d)");
        System.out.println("main() : x = " + d.x);

    }

    static void change(Data2 d) { // 참조형 매개변수
        d.x = 1000;
        System.out.println("change() : x = " + d.x);
    }
}
```
여기서 change메서드에서 매개변수 d로 x의 값을 1000으로 변경  

### 3.9 참조형 반환타입  
>> 반환타입이 '참조형'이라는 것은 메서드가 '객체의 주소'를 반환한다는 것을 의미한다.  

### 3.10 재귀 호출  
* 메서드의 내부에서 메서드 자신을 다시 호출하는 것.  
```java
void method() {
    method(); //재귀호출
}
```

### 3.11 클래스 메서드와 인스턴스 메서드  
>> **인스턴스 메서드 - 인스턴스(iv의 집합)가 필요한 메서드**  
>> **클래스 메서드 - 인스턴스(iv의 집합)가 필요없는 메서드**  

## 4. 오버로딩

### 4.1 오버로딩이란?
* 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것.  

### 4.2 오버로딩의 조건
>> 1. 메서드의 이름이 같아야 한다.
>> 2. 매개변수의 개수 또는 타입이 달라야 한다.
>> 3. 반환타입은 상관없다.  

### 4.3 오버로딩의 예  
```java
int add(int a, int b) {return a + b;}
long add(long a, long b) {return a + b;}
long add(int[] a) {
    long result = 0;

    for (int i = 0; i < a.length; i++) {
        result += a[i];
    }
    return result;
}
```
### 4.4 오버로딩의 장점  
* 오버로딩으로 여러 메서드들이 **println**이라는 하나의 이름으로 정의될 수 있다면, **println**이라는 이름만 기억하면 되믜로 기억하기 쉬워서 오류의 가능성을 줄일 수 있다.  
```java
class OverloadingEx {
    public static void main(String args[]) {
        MyMath3 mm = new MyMath3();
        System.out.println("mm.add(3, 3) 결과:"    + mm.add(3,3));
        System.out.println("mm.add(3L, 3) 결과: "  + mm.add(3L,3));
        System.out.println("mm.add(3, 3L) 결과: "  + mm.add(3,3L));
        System.out.println("mm.add(3L, 3L) 결과: " + mm.add(3L,3L));

        int[] a = {100, 200, 300};
        System.out.println("mm.add(a) 결과: " + mm.add(a));
    }
}

class MyMath3 {
    int add(int a, int b) {
        System.out.print("int add(int a, int b) - ");
        return a+b;
    }

    long add(int a, long b) {
        System.out.print("long add(int a, long b) - ");
        return a+b;
    }

    long add(long a, int b) {
        System.out.print("long add(long a, int b) - ");
        return a+b;
    }

    long add(long a, long b) {
        System.out.print("long add(long a, long b) - ");
        return a+b;
    }

    int add(int[] a) {		// 배열의 모든 요소의 합을 결과로 돌려준다.
        System.out.print("int add(int[] a) - ");
        int result = 0;
        for(int i=0; i < a.length;i++) {
            result += a[i];
        }
        return result;
    }
}
```
### 4.5 가변인자와 오버로딩

```java
class VarArgsEx {
    public static void main(String[] args) {
        String[] strArr = { "100", "200", "300" };

        System.out.println(concatenate("", "100", "200", "300"));
        System.out.println(concatenate("-", strArr));
        System.out.println(concatenate(",", new String[]{"1", "2", "3"}));
        System.out.println("["+concatenate(",", new String[0])+"]");
        System.out.println("["+concatenate(",")+"]");
    }

    static String concatenate(String delim, String... args) {
        String result = "";

        for(String str : args) {
            result += str + delim;
        }

        return result;
    }

/*
	static String concatenate(String... args) {
		return concatenate("", args);
	}
*/
} // class
```
concatenate메서드는 매개변수로 입력된 문자열에 구분자를 사이에 포함시켜 결합해서 반환한다. 가변인자로 매개변수를 선언했기 때문에 문자열을 개수의 제약없이 매개변수로 지정할 수 있다.  

## 5. 생성자

### 5.1 생성자란?
* 생성자는 인스턴스가 생성될 때 호출되는 인스턴스의 초기화 메서드이다.
>> **1.생성자의 이름은 클래스의 이름과 같아야 한다.**  
>>**2. 생성자는 리턴 값이 없다.**
* 연산자는 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다!!!

### 5.2 기본 생성자  
```java
클래스 이름() { }
Card() { }
```
>> **기본 생성자가 컴파일러에 의해서 자동 추가되는 경우는 생성자가 하나도 없을 때 뿐이다.**

### 5.3 매개변수가 있는 생성자  
```java
class Car {
    String color;		// 색상
    String gearType;	// 변속기 종류 - auto(자동), manual(수동)
    int door;			// 문의 개수

    Car() {}
    Car(String c, String g, int d) {
        color = c;
        gearType = g;
        door = d;
    }
}

class CarEx {
    public static void main(String[] args) {
        Car c1 = new Car();
        c1.color    = "white";
        c1.gearType = "auto";
        c1.door = 4;

        Car c2 = new Car("white", "auto", 4);

        System.out.println("c1의 color=" + c1.color + ", gearType=" + c1.gearType+ ", door="+c1.door);
        System.out.println("c2의 color=" + c2.color + ", gearType=" + c2.gearType+ ", door="+c2.door);
    }
}
```
Car c = new Car("white", "auto", 4);  
클래스를 작성할 때 다양한 생성자를 제공함으로써 인스턴스 생성 후에 추가로 초기화를 하지 않아도 되게 하는 것이 좋다.  

### 5.4 생성자에서 다른 생성자 호출하기 - this(), this  
>> **생성자의 이름으로 클래스이름 대신 this를 사용한다.**
>> **다른 생성자를 호출할 때 반드시 철 줄에서만 호출이 가능하다.**
```java
class Car {
    String color;		// 색상
    String gearType;	// 변속기 종류 - auto(자동), manual(수동)
    int    door;		// 문의 개수

    Car() {
        this("white", "auto", 4);
    }

    Car(String color) {
        this(color, "auto", 4);
    }
    Car(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}

class CarEx2 {
    public static void main(String[] args) {
        Car c1 = new Car();
        Car c2 = new Car("blue");

        System.out.println("c1의 color=" + c1.color + ", gearType=" + c1.gearType+ ", door="+c1.door);
        System.out.println("c2의 color=" + c2.color + ", gearType=" + c2.gearType+ ", door="+c2.door);
    }
}
```
>> **this** 인스턴스 자신을 가리키는 참조 변수, 인스턴스의 주소가 저장되어 있으며 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.  
>> **this(), this(매개변수)** 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.  

### 5.5 생성자를 이용한 인스턴스의 복사
```java
class Car3 {
    String color;		// 색상
    String gearType;	// 변속기 종류 - auto(자동), manual(수동)
    int    door;		// 문의 개수

    Car3() {
        this("white", "auto", 4);
    }

    Car3(Car3 c) {	// 인스턴스의 복사를 위한 생성자.
        color    = c.color;
        gearType = c.gearType;
        door     = c.door;
    }
    
    Car3(String color, String gearType, int door) {
        this.color    = color;
        this.gearType = gearType;
        this.door     = door;
    }
}
class CarEx3 {
    public static void main(String[] args) {
        Car3 c1 = new Car3();
        Car3 c2 = new Car3(c1); // c1의 복사본 c2를 생성한다.
        System.out.println("c1의 color=" + c1.color + ", gearType=" + c1.gearType+ ", door="+c1.door);
        System.out.println("c2의 color=" + c2.color + ", gearType=" + c2.gearType+ ", door="+c2.door);
        c1.door=100; // c1의 인스턴스변수 door의 값을 변경한다.
        System.out.println("c1.door=100; 수행 후");
        System.out.println("c1의 color=" + c1.color + ", gearType=" + c1.gearType+ ", door="+c1.door);
        System.out.println("c2의 color=" + c2.color + ", gearType=" + c2.gearType+ ", door="+c2.door);
    }
}
```
>> 인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.
>> 1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
>> 2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

## 6. 변수의 초기화

### 6.1 변수의 초기화
>> 멤버 변수 (클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택이지만, 지역 변수의 초기화는 필수이다.  

>> 멤버 변수의 초기화 방법  
>> 1. 명시적 초기화  
>> 2. 생성자  
>> 3. 초기화 블럭  
>> -인스턴스 초기화 블럭 : 인스턴스 변수를 초기화 하는데 사용.  
>> -클래스 초기화 블럭 : 클래스 변수를 초기화 하는데 사용.  

## 6.2 명시적 초기화  
변수를 선언과 동시에 초기화 하는 것.  

### 6.3 초기화 블럭  
>> **클래스 초기화 블럭** 클래스 변수의 복잡한 초기화의 사용  
>> **인스턴스 초기화 블럭** 인스턴스 변수의 복잡한 초기화에 사용
```java
class BlockEx {
    static {
        System.out.println("static { }");
    }
    // 클래스 초기화 블럭

    {
        System.out.println("{ }");
    }
    // 인스턴스 초기화 블럭

    public BlockEx() {
        System.out.println("생성자");
    }

    public static void main(String args[]) {
        System.out.println("BlockEx be = new BlockEx(); ");
        BlockEx be = new BlockEx();

        System.out.println("BlockEx be2 = new BlockEx(); ");
        BlockEx be2 = new BlockEx();
    }
}
```

### 6.4 멤버변수의 초기화 시기와 순서

>> **클래스변수의 초기화 시점** 클래스가 처음 로딩될 떄 단 한번 초기화 된다.
>> **인스턴스변수의 초기화 시점** 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.  

>>**클래스변수의 초기화 시점** 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭  
>>**인스턴스변수의 초기화 시점** 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
```java
class Product {
    static int count = 0;  // 생성된 인스턴스의 수를 저장하기 위한 변수
    int serialNo;          // 인스턴스 고유의 번호

    {
        ++count;
        serialNo = count;
    }

    public Product() {}     // 기본 생성자, 생략가능
}

class ProductEx {
    public static void main(String args[]) {
        Product p1 = new Product();
        Product p2 = new Product();
        Product p3 = new Product();

        System.out.println("p1의 제품번호(serial no)는 " + p1.serialNo);
        System.out.println("p2의 제품번호(serial no)는 " + p2.serialNo);
        System.out.println("p3의 제품번호(serial no)는 " + p3.serialNo);
        System.out.println("생산된 제품의 수는 모두 "+Product.count+"개 입니다.");
    }
}
```