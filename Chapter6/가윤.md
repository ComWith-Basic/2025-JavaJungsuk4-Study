## 

1. **객체 지향 언어** 
    
    → 기존 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 언어 
    
    - 주요특징
        1. 코드의 재사용이 높다 → 기존의 코드를 이용하기 때문
        2. 코드의 관리가 용이하다 → 코드간의 관계를 이용
        3. 신뢰성이 높은 프로그래밍을 가능하게 한다
2. **클래스와 객체**
    - 클래스와 객체의 정의와 용도
        - 클래스의 정의 → 객체를 정의
        - 클래스의 용도 → 객체를 생성하는데 사용
        - 객체의 정의 → 실제로 존재
        - 용도 → 객체가 가지고 있는 기능과 속성에 따라 다름
        - Ex) TV(객체)가 필요한 거지 TV 설계도(클래스)가 필요한 건 아님 단지 제품(객체)을 만드는데만 사용, 설계도가 있어야 TV가 만들어짐
        
          → 먼저 클래스를 작성한 후 객체 생성 후 사용
        
    - 객체와 인스턴스
        - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며,
        - 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함
        
               →  인스턴스는 객체와 같은 의미지만 **객체**는 모든 인스턴스를 대표하는 **포괄적인 의미**                          **인스턴스**는 **어떤 클래스로부터 만들어진 것**인지를 강조
        
        Ex) 책상은 객체다 / 책상은 책상 클래스의 인스터스다
        
    - 객체의 구성요소 → 속성과 기능
        - 객체 = 속성 + 기능, 두 종류의 구성요소로 이루어져있다, 속성과 기능을 그 객체의 멤버라 한다
        - 속성 == 멤버변수, 기능 == 메서드
        - Ex) 채널(속성) → int channel, 채널 높이기 → channelUp(){…}
            
            ```java
            class Tv{ 
            String color;
            boolean power;
            int channel;
            //속성
            
            void power() {power = !power;}
            void channelUp() {channel++;}
            //기능
            ```
            
    - 인스턴스의 생성과 사용
        
         → 인스턴스 생성하는 방법
        
        ```java
        //예제 1
        class Tv{
        //Tv의 속성(멤버변수)
        String color; //참조형이라 기본형 null
        boolean power; //기본형 false
        int channel; // 기본형 0
        
        //Tv의 기능(메서드)
        void power() {power = !power;}
        void channelUp() {channel++;}
        }
        
        class Tvtest{
        public static void main (String args[]){
        Tv t; //tv클래스 타입의 참조변수 t를 선언,인스턴스가 생성되지 않았기때문에 참조변수로 아무것도 할 수 없음
        t = new Tv(); //연산자 new로 인해 인스턴스가 메모리의 빈 공간에 생성
        t.channel = 7; //t가 참조변수 channel이 멤버변수 
        t.channelUp();
        System.out.println("현재 채널은 "+t.channel+"입니다.");
        // 현재 채널은 8입니다.
        
        ```
        
        ![KakaoTalk_Photo_2025-09-28-11-55-31 001.jpeg](attachment:97695c63-5563-4d1c-b941-66f6e93ba689:a34f546b-ad74-4345-bd88-59e3eeaacdab.png)
        
        ```java
        //예제2
        class Tv{
        //Tv의 속성(멤버변수)
        String color; //참조형이라 기본형 null
        boolean power; //기본형 false
        int channel; // 기본형 0
        
        //Tv의 기능(메서드)
        void power() {power = !power;}
        void channelUp() {channel++;}
        void channelDown() {--channel;}
        }
        
        class Tvtest2{
        public static void main (String args[]){
        Tv t1 = new Tv();
        Tv t2 = new Tv();
        System.out.println("t1의 체널값은 "+t1.channel+"입니다."); //값 0
        System.out.println("t2의 체널값은 "+t2.channel+"입니다."); //값 0
        t1.channel = 7; 
        System.out.println("t1의 channel값을 7로 변경했습니다.")
        
        System.out.println("t1의 체널값은 "+t1.channel+"입니다."); //값 7
        System.out.println("t2의 체널값은 "+t2.channel+"입니다."); //값 0
        
        ```
        
        ```java
        //예제3
        class Tvtest3{
        public static void main (String args[]){
        Tv t1 = new Tv();
        Tv t2 = new Tv();
        System.out.println("t1의 체널값은 "+t1.channel+"입니다."); //값 0
        System.out.println("t2의 체널값은 "+t2.channel+"입니다."); //값 0
        t2 = t1;
        t1.channel = 7; 
        System.out.println("t1의 channel값을 7로 변경했습니다.")
        
        System.out.println("t1의 체널값은 "+t1.channel+"입니다."); //값 7
        System.out.println("t2의 체널값은 "+t2.channel+"입니다."); //값 7
        
        ```
        
        ![스크린샷 2025-09-28 오후 12.26.34.png](attachment:17b728f6-4d52-412c-bbbd-5dcc12103459:스크린샷_2025-09-28_오후_12.26.34.png)
        
        t2 = t1 → t2가 참조하던 인스턴스는 더이상 사용할 수 없고 t1의 인스턴스를 같이 참조한다(t2 값 바꾸면 t1값도 바뀜)
        
- 객체 배열
    
    Tv tv1, tv2, tv3 → **Tv [] tvArr = new Tv[3]** + tvArr[0] = new Tv();…tvArr[2] = new Tv();
    
    or Tv [] tvArr = new Tv[100]; for(int i = 0; i<tvArr.length;i++){tvArr[i] = new Tv();}
    
    ```java
    //예제4
    class Tvtest4{
    public static void main (String args[]){
    **Tv [] tvArr = new Tv[3];**
    
    for(int i = 0; i<tvArr.length;i++){
    tvArr[i] = new Tv();
    tvArr[i].channel = i+10;
    }
    for(int i=0; i<tvArr.length;i++){
    tvArr[i].channelUp();
    System.out.printf("tvArr[%d].channel=%d%n",i,tvArr[i].channel);
    ```
    
    ```java
    +printf / println 차이
    int num = 5;
    		System.out.print("print ! " + num + "\n");	
    		System.out.printf("printf ! %d \n", num);	//c언어에서 했던거처럼
    		System.out.println("println ! " + num);	//실행시 한줄띄어짐
    ```
    
- 클래스의 또 다른 정의
    1. 클래스 - 데이터와 함수의 결합
        - 변수(1) → 배열(1,2,3) → 구조체(1, 10.0f, ’a’) → 클래스(1, 10.0f, ’a’ + 함수)
            - 변수 : 하나의 데이터, 배열: 같은 종류의 여러 데이터, 구조체: 서로 관련된 데이터(종류 상관X), 클래스: 데이터와 함수의 결합
    2. 클래스 - 사용자정의 타입
        - 프로그래밍언어에서 제공하는 자료형외에 프로그레머가 서로 관련된 변수들을 묶어서 하나의 타입으로 추가하는 것을 사용자정의 타입이라고한다. → 자바의 경우 클래스가 곧 사용자 정의 타입(Ex 배열 활용)
            - 기본형 → int hour1,  hour2, hour3
            - 사용자정의 타입 →1.  int [] hour = new int[3] 2. class Time{ int hour; …}
1. **변수와 메서드**
    - 선언 위치에 따른 변수의 종류
        - 변수 → 클래스 변수, 인스턴스변수, 지역변수 ⇒ 종류를 결정짓는 중요한 요소가 선언된 위치
        - 멤버변수를 제외한 나머지 변수들이 지역변수, 멤버변수 중 static 붙은 게 클래스, 안붙은 게 인스턴스
            
            ![KakaoTalk_Photo_2025-09-28-14-55-55.jpeg](attachment:7e70699a-bda0-4675-b2df-8b2cb9378008:KakaoTalk_Photo_2025-09-28-14-55-55.jpeg)
            
        - 인스턴스 변수 → 클래스 영역에 선언, 클래스의 인스턴스를 생성할 때 만들어짐, 독립적인 저장공간을 가지기때문에 서로 다른 값을 가질 수 있음 ⇒ 인스턴스마다 고유한 상태를 유지해야하는 속성 선언
        - **클래스 변수** → static + 인스턴스 변수, 인스턴스와 달리 모든 인스턴스가 공통된 저장공간 즉 변수를 공유, 인스턴스변수와 달리 인스턴스를 생성하지않고도 언제라도 바로 사용할 수 있음(클래스 이름.클래스변수)
        - 지역변수 → 메서드 내에 선언, 메서드내에서만 사용가능, for,while문에서 선언된 변수는 중괄호안에서만 사용할 수 있고 벗어나면 사용불가(int i)
    - 클래스변수와 인스턴스 변수
        - Ex) 트럼프 카드의 속성 ⇒⇒ 클래스변수: 다 같은 폭,높이→ 만약 높이 수정이 필요하면 한카드의 높이만 수정해도 모든카드의 높이가 바뀜 // 인스턴스변수: 무늬(하트,클로버…),숫자
            
            ```java
            class Card{
                String kind; // 인스턴스
                int number;
                static int width = 100; // 클래스(고정)
                static int height = 250;
            }
            
            class CardTest {
                public static void main(String args[]) {
                    System.out.println("Card.width = " + Card.width); //Card c1 = new card();이런거 안해도 쓸 수 있음
                    System.out.println("Card.height = " + Card.height);
            
                    Card c1 = new Card();
                    c1.kind = "Heart";
                    c1.number = 7;
            
                    Card c2 = new Card();
                    c2.kind = "Spade";
                    c2.number = 4;
            
                    System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width +"," + c1.height + ")");
                    System.out.println("c2는 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + "," + c2.height + ")");
                    System.out.println("c1의 width와 height를 각각 50, 80으로 변경합니다.");
                    c1.width = 50;
                    c1.height = 80;
            
                    System.out.println("c1은 " + c1.kind + ", " + c1.number+"이며, 크기는 (" + c1.width + "," + c1.height + ")");
                    System.out.println("c2는 " + c2.kind + ", " + c2.number+"이며, 크기는 (" + c2.width + "," + c2.height + ")");
                }
            ```
            
            ![스크린샷 2025-09-28 오후 3.45.27.png](attachment:cb007abd-33e3-4afb-852d-911e4bc80a18:스크린샷_2025-09-28_오후_3.45.27.png)
            
            - width, heigth은 클래스변수이므로 c1,c2 저장공간을 참조 == 하나의 값바꾸면 다 바뀜
    - 메서드
        
        → 특정 작업을 수행하는 일련의 문장을 하나로 묶은 것 aka 함수
        
        - Ex) Math.sqrt(), println()등 ⇒ 과정은 몰라도 되고(블랙박스) 입력값, 출력값만 알면됨
        - 사용하는 이유
            - 높은 재사용성
            - 중복된 코드 제거
            
            ![KakaoTalk_Photo_2025-09-28-15-57-58.jpeg](attachment:d1b9f22c-161b-4476-b52c-9ea9b16d5bc6:a56a1dd8-de66-48da-8b79-d4241c21de77.png)
            
            - 프로그램의 구조화(p.251)
    - 메서드의 선언과 구현
        - 메서드 → 선언부(머리), 구현부(몸통)
        - Ex) int add(int a, int b) → 선언부 / {int result = a+b} → 구현부
        - **메서드 선언부** → 메서드 이름(add), 매개변수 선언(int x, int y), 반환타입(int)
        - **매개변수 선언** → 일반적인 변수 선언과 달리 두 변수의 타입이 같아도 변수의 타입 생략X
            - 일반적인 변수 선언 → 프로그램에서 사용되는 값을 저장하는 공간입니다
                - int count; count =10;
            - 매개변수 선언 → 메서드가 외부로부터 값을 입력받기 위해 선언하는 변수
                - int add(int a, int b)
        - 반환값이 없는 경우 void로 (Ex. 사용자의 입력이 필요없이 1~9까지 구구단)
        - **메서드 구현부** → 메서드 선언 다음에 오는 괄호 {}
        - **Return 문** → void가 아닌 경우에 무조건 있어야함
            - 반환타입과 일치하거나 자동 형변환이 가능한 것이여야한다
                
                ```java
                int add (int x, int y){
                int result = x+y;
                return result;}
                ```
                
            - 반환값은 무조건 하나 → 메서드로의 입력(매개변수)은 여러 개일 수 있어도 출력(반환값)은 최대 하나만
        - **지역변수** → 메서드 내에서 선언된 변수, 서로 다른 메서드라면 같은 이름 변수 가능
            
            ```java
            int add (int x, int y){
            int result = x+y;
            return result;}
            
            int multiply (int x, int y){
            int result = x*y;
            return result;}
            ```
            
    - 메서드의 호출 → 메서드 이름(값1,값2…)
        - print99( ),
        - **int result = add (3,5)** → 괄호안에 지정해준 값들을 인자라고 함
            
            ![KakaoTalk_Photo_2025-09-29-15-45-17.jpeg](attachment:03f6841d-6d8b-47cd-9efa-d8281a617eb7:KakaoTalk_Photo_2025-09-29-15-45-17.jpeg)
            
            - int result = add (1.0, 2.0) → 오류
        - 메서드의 실행흐름(p.256)
            
            ```java
            MyMath mm = new MyMath();
            
            long value = mm.add(1l,2l)
            ```
            
        - return문
            - 현재 실행중인 메서드를 종료하고 호출한 메서드로 돌아감
                
                ```java
                int max (int a, int b){
                if (a>b)
                return a; //if 조건식의 결과에 따라 리턴문이 실행하지않을 수 있으므로
                
                else //추가해서 언제나 결과값이 반환되게 해야됨
                return b;
                }
                ```
                
                ```java
                public class Main{
                    public static int max (int a, int b){
                        if(a>b)
                            return a;
                        else
                            return b;
                    }
                
                    public static void main(String args[]){
                        int result = max(10,20);
                        System.out.println("최댓값: "+ result);
                    }
                }
                ```
                
        - 반환값
            - int result = x+y; return result; → return x+y;
            - diff 메서드 → 두 개의 정수를 받아서 그 차이를 절대값으로 반환
            - abs → 절대값
            
            ```java
            int diff (int x, int y){
            int result = abs(x-y);
            return result;}
            ```
            
            ```java
            int diff (int x, int y){
            return abs(x-y); }
            ```
            
            ```java
            int abs(int x) {
            if(x>=0){ return x;} else {return -x;}}
            ```
            
            ```java
            int abs(int x) {
            return x>=0 ? x: -x;}
            ```
            
        - 매개변수의 유효성 검사 → return 0;
- JVM의 메모리 구조 → 메모리를 용도에 따라 여러 영역으로 나누어 관리
    1. 메서드 영역 → 어떤 클래스가 사용되면, jvm은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보를 여기에 저장 == 클래스변수도 여기에 저장
    2. 힙 → 인스턴스가 생성되는 공간 
    3. 호출스택 → 메서드의 작업에 필요한 공간을 제공, 메서드가 호출되면 호출스택에 호출된 메서드를 위한 메모리가 할당, 메서드가 작업을 수행하는동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용, 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.
        - 첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련
        - 두 번째 메서드가 호출되면 첫 번째 메서드는 수행을 멈추고 두번째 메서드 수행 시작
        - 두 번째가 끝나면 호출스택의 메모리 공간이 반환되고 다시 첫번째로
        - == 제일 상위에 있는 호출 스택이 현재 실행중인 메서드, 나머지는 대기상태
            
            ![KakaoTalk_Photo_2025-09-30-11-30-55.jpeg](attachment:d245bd9a-bfad-4daa-9295-84fca63b1e67:KakaoTalk_Photo_2025-09-30-11-30-55.jpeg)
            
        
        ```java
        class CallStackTest {
        public static void main(String[] args){
        fristMethod();}
        
        static void firstMethod(){
        secondMethod();}
        
        static void secondMethod(){
        System.out.println("secondMethod()");
        }
        }
        ```
        
        ![KakaoTalk_Photo_2025-09-30-11-43-58.jpeg](attachment:d5df370d-b296-42be-a4b5-85171df4d887:KakaoTalk_Photo_2025-09-30-11-43-58.jpeg)
        
- 기본형 매개변수와 참조형 매개변수
    - 기본형 → 기본형 값 복사 = read only , 참조형 → 인스턴스의 주소 = read & write
    
    ```java
    class Data ( int x; }
    class PrimitiveParamEx { 
    public static void main(String[] args) 
     Data d = new Data(); 
    d.x =10; 
    
    System.out.println("main() :X="+d.x); 
    
    change(d.x); 
    System.out.println("After change(d.x)"); 
    System.out.println("main() :x="+dx); 
    static void change(int x) [ // 기본형매개변수 x=1000; 
    x = 1000;
    System.out.println("change():X=" + x); // d.x로 바꿔야됨
    ```
    
    ![KakaoTalk_Photo_2025-09-30-11-54-00.jpeg](attachment:b6062955-8060-4a42-8fde-0a7018050480:KakaoTalk_Photo_2025-09-30-11-54-00.jpeg)
    
    d.x의 값이 변경된 게 아니라 체인지 메서드의 매개변수 x의 값이 변경 = 복사본이 변경
    
    ```java
    printArr(arr); //배열의 모든 요소를 출력
    sortArr(arr); // 배열을 정렬
    printArr(arr); // 정렬후 결과를 출력
    ```
    
    ```java
    int add (int a, int b) {return a+b;} //하나의 값만
    ->
    void add(int a, int b, int[] result){result[0] = a+b;}
    //여러개값 반환 가능
    ```
    
- 참조형 반환타입
    - 반환타입도 참조형(객체의 주소) 가능
        
        ```java
        class Data {int x;} 
        class ReferenceReturnEx {
        public static void main(String[] args) 
        Data d= new Data (); 
        d.x = 10; 
        Data d2 = copy (d);
        System.out.println("d.x ="+d.x); 
        
        System.out.Println("d2.x-"+d2.x); 
        static Data copy (Data d){
        Data tmp = new Data (); //새로운 객체 tmp를 생성
        tmp.x =d.x; //데이터 복사
        return tmp; //복사한 객체의 주소를 반환
        }
        ```
        
        ![KakaoTalk_Photo_2025-09-30-14-11-08.jpeg](attachment:53c7380d-d1db-480d-b8ed-dfd82117421c:KakaoTalk_Photo_2025-09-30-14-11-08.jpeg)
        
- 재귀호출→ 메서드의 내부에서 메서드 자신을 다시 호출하는 것
    
    ```java
    void method() {method();}
    ```
    
    - 호출된 메서드는 값에 의한 호출을 통해 원래의 값이 아닌 복사된 값으로 들어오기 때문에 호출한 메서드와 관계없이 독립적인 작업 수행이 가능
    - 위 코드처럼 짜면 무한반복 == 조건문이 꼭 필요
    
    ```java
    void method(int n){ 
    if (n==0) return;//종료
    System.out.println(n); method(--n); //method(int n)을 호출}
    ->
    {while (n!=0){System.out.println(n--);}}
    ```
    
    - Ex) 팩토리얼 → 한 숫자가 1이 될때까지 1씩 감소시키면서 계속해서 곱해나가는 것
        - f(n) = n * f(n-1)
            
            ```java
            class FactorialTest{
                public static void main(String args[]){
                    int result = factorial(3);
            
                    System.out.println(result);
                }
            
                static int factorial(int n){
                    int result=0;
                    if (n==1)
                        result=1;
                    else result = n*factorial(n-1);
                    return result;}}
            ```
            
        - 계속 이러지면 스택의 저장한계를 넘게 됨 → 스택 오버플로우
            - 매개변수의 유효성 검사가 꼭 필요
                
                ```java
                 static int factorial(int n){
                        if(n<=0||n>12) return -1; //13이상이면 int 범위를 넘어감
                        if (n==1) result=1;
                        else result = n*factorial(n-1);
                ```
                
- 클래스 메서드와 인스턴스 메서드
    - 인스턴스와 관계없는(인스턴스 변수나 인스턴스메서드를 사용하지 않는)메서드를 클래스메서드(static메서드)로 정의
        1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
            - 생성된 인스턴스는 서로 독립적, 각 인스턴스 변수는 서로 다른 값을 유지 But 모든 인스턴스는 같은 값을 유지해야하므로 static를 붙여 클래스 변수로 정의해야함
        2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다
            - 클래스변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 올라감
        3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다
            - 반면에 인스턴스 메서드에서는 static붙은 변수를 사용할 수 있음(메모리에 이미존재)
        4. 메서드 내에서 인스턴스 변수를 사용하지않는다면, static을 붙이는 것을 고려한다 → 호출시간이 빨라짐
        5. p.279
- 클래스 멤버와 인스턴스 멤버간의 참조와 호출
1. **오버로딩**
    - 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있음 = 한 클래스내에 같은 이름의 메서드를 여러 개 정의 하는 것 ⇒ 메서드 오버로딩 or 오버로딩
    - 오버로딩의 조건
        - 메서드의 이름이 같아야한다
        - 매개변수의 개수 또는 타입이 달라야한다
        - int add(int x,int y) / long add(int x,int y) → 타입과 개수가 일치하므로 구별 X = 오버로딩X
        - long add(int x,long y) / long add(long x,int y) → 오버로딩O
    - 가변인자와 오버로딩
        - 가변인자 → 매개변수 개수를 동적으로 지정할수있음, 타입… 변수명 (Ex. printf)
        - public PrintStream printf (String format, Object… args) {…} → 가변인자는 항상 마지막 매개변수여야 함
            
            ![KakaoTalk_Photo_2025-10-05-08-54-17.jpeg](attachment:ca9949c0-91d5-4dda-88a8-5a585736e6df:1184a96f-9569-4107-9ba8-3e0f242532f1.png)
            
        - 배열도 가능 → (new Streing[] {”A”, “B”}) / 결과 : String result = c() XX 인자 있어야함 (null)은 가능
2. **생성자**
    - 생성자 → 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드 ==인스턴스 생성X, 인스턴스 변수들의 초기화에 사용되는 특별한 메서드일뿐
        - 조건 - 생성자의 이름은 클래스의 이름과 같아야 한다. - 생성자는 리턴 값이 없다(void 사용X)
        - Card c = new Card() 생성자
    - 기본 생성자 → 클래스에 정의된 생성자가 하나도 없을 때 컴파일러가 추가
        
        ```java
        class Data1{int value;} // 자동으로 기본 생성자 추가
        class Data2{int value; Data2(int x) value = x;}
        
        class Main{
        public static void main (String[] args){
        Data1 d1 = new Data1();
        Data2 d2 = new Data2(); // 에러, int x로 정의, 값을 추가해주거나 클래스 data2에 data2()를 추가로 정의
        ```
        
    - 매개변수가 있는 생성자
        
        ```java
        class Car{
        String color;
        String gearType;
        int door;
        
        Car(){} //생성자
        Car(String c, String g, int d){ //생성자
        color = c; gearType = g; door =d;}
        }
        ```
        
    - 생성자에서 다른 생성자 호출하기 → this()→ 생성자, this→ 참조변수
        
        ```java
        class Car {
        String color 
        String gearType;
        int door; 
        
         Car(){ 
         this("white", "auto", 4);} 
         
         Car(String color){
         this(color, "auto", 4);} 
         
         Car (String color, String gearType, int door) {
         this.color = color; 
         this.gearType = gearType; 
         this.door = door;
         }
        ```
        
    - 생성자를 이용한 인스턴스의 복사
        
        ```java
        class Car {
        String color 
        String gearType;
        int door; 
        
         Car(){ 
         this("white", "auto", 4);} 
         
         Car(Car c){
         color  = c.color;
        gearType = c.gearType;
        door = c.door; 
         }
         Car(String color){
         this(color, "auto", 4);} 
         
         Car (String color, String gearType, int door) {
         this.color = color; 
         this.gearType = gearType; 
         this.door = door;
         }
         
         {Car c1 = new Car();
         Car cw = new Car(c1); // 복사본}
        ```
        
        - c1, c2는 독립적으로 c1 값이 바뀌어도 c2에 영향X
3. **변수의 초기화**
    - 변수의 초기화 → 변수를 선언하고 처음으로 값을 저장하는 것
        - 멤버변수는 초기화하지 않아도 자동적으로 초기화 진행 But 지역변수는 무조건 초기화 해줘야 됨
            
            ![KakaoTalk_Photo_2025-10-05-09-32-00.jpeg](attachment:3984f03d-8105-4fd5-ba99-f0cda80e0e9b:KakaoTalk_Photo_2025-10-05-09-32-00.jpeg)
            
    - 명시적 초기화
        - int door = 4; Engine e = new Engine();
    - 초기화 블럭 → 클래스 초기화 블럭, 인스턴스 초기화블럭
        - 인스턴스 초기화블럭
            - 단순 클래스내에서 블럭{} 만들고 코드 짜면됨
            - 생성자와 같이 인스턴스 생성할 때 마다 수행(생성자보다 먼저 수행)
            - 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자
        - 클래스 초기화 블럭
            - static + 인스턴스 초기화 블럭
            - 클래스가 메모리에 처음 로딩될 때 한번만 수행
            - 기본값 → 명시적 초기화 → 클래스 초기화 블럭
